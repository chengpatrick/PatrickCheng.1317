THE INTERPRETER

The interpreter project is written in java in the Eclipse IDE, so when compling the project please use Eclipse IDE or it might not work.

The interpreter project has three main class files: 
Interpreter.java, Printer.java, Tokenizer.java

Interpreter.java:
The interpreter is implemented by using the object-oriented approach (OO). The main reason I used OO is because I felt like this may be simpler and the direct relationship between objects and classes and more visible and easier to manipulate. There are a total of 19 classes. The code follows the principle of encapsulation. The interpreter can be split into three parts which are parser, printer and executor. The way that the interpreter works is that it follows the BNF grammar for Core. The program first tokenizes the program using the previously implemented tokenizer. Once the program has been tokenized, the parser comes in and parses the program. It builds the data structure using each piece of the tokens and treat each node as a separate independent object. Next the printer runs, and prints out the parsed program to the standard output in a pretty print matter. Last, the executor runs and executes all the read and write statements if they exsist. The executor will also calculate any change in the variable value. The interpreter has multiple classes, the way I designed the classes is based on BNF for Core, each non-termial has a class (Prog has a class, Stmt has a class...)

When running the java file for the interpreter, thethe program will ask for the user to input the file to be read in first.There are some test files in the data folder already such as test1.txt. So to enter the file just type in "data/test2.txt" (without the ""), "data/" is necessary because test1.txt is in the data folder. The interpreter will take in the test file data, tokenizes it, parse it and print the parsed program. After the program is printed the executor will come in and execute any read/write statement or calculation in the program. If a read x1 exist, something like "Enter value for x1: " will pop up and the user will have to enter a integer and press enter/return in order for the program to read the value that was just entered. 

When implementing the interpreter, I started by drawing a relationship graph of all the BNF grammar so I can see which parts are related to others. Then I started implementing from the smallest parts that don't depend on a lot on other non-terminals (such as <id> and <comp_op>). Then I start building up from there, all the way up to <prog>. I implemented the parser and printer first so I can test directly and see if everything is going in and coming out with the correct values. Everything was easy to implement once the visualization of the program is drawn out. I implemented the functions using recursive descent because this is the easiest way to implement the parser, printer and executor this way. The interpreter project took much longer to complete compared to the tokenizer due to the massive amount of classes and things that needs to be tested. Most of the code is in the Interpreter.java file. The printer.java is not the same printer for the interpreter, it is used for text indentation like for pretty printing if then else statements. The tokenizer.java is from the previous project. 